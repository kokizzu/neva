// === Zip ===

pub type ZipResult<T, R> struct {
    left T
    right R
}

// Produces a stream of tuples of the form (left, right)
// where left is from the left stream and right is from the right stream.
// Stops when either stream is exhausted.
#extern(stream_zip)
pub def Zip<T, R>(left stream<T>, right stream<R>) (res stream<ZipResult<T, R>>)

// === ZipMany ===

// Produces a stream of lists where each list contains items from the
// corresponding positions of the input streams. Stops when any stream is
// exhausted.
#extern(stream_zip_many)
pub def ZipMany<T>([data] stream<T>) (res stream<list<T>>)

// === Product ===

pub type ProductResult<T, Y> struct {
    first T
    second Y
}

// Product waits for each input stream to complete,
// then outputs stream of every combination of elements from the first stream with
// elements from the second.
#extern(stream_product)
pub def Product<T, Y>(first stream<T>, second stream<Y>) (data stream<ProductResult<T, Y>>)
