package golang

type templateData struct {
	CompilerVersion string
	ChanVarNames    []string
	FuncCalls       []templateFuncCall
	Trace           bool
	TraceMetadata   templateTraceMetadata
}

type templateFuncCall struct {
	Ref    string
	Config string
	IO     templateIO
}

type templateIO struct {
	In  map[string]string
	Out map[string]string
}

type templateTraceMetadata struct {
	Program  templateTraceProgramMetadata
	Compiler templateTraceCompilerMetadata
}

type templateTraceProgramMetadata struct {
	ModulePath    string
	ModuleVersion string
	MainPackage   string
}

type templateTraceCompilerMetadata struct {
	Version string
}

var mainGoTemplate = `// Code generated by Neva v{{.CompilerVersion}}. DO NOT EDIT.
package main

import (
    "fmt"
    "os"
    "context"

    "github.com/nevalang/neva/internal/runtime"
    "github.com/nevalang/neva/internal/runtime/funcs"
)

func main() {
    var (
        {{- range .ChanVarNames}}
        {{.}} = make(chan runtime.OrderedMsg)
        {{- end}}
    )
    {{- if .Trace }}

    interceptor := runtime.NewDebugInterceptor()

    metadata := runtime.TraceMetadata{
        Program: runtime.TraceProgramMetadata{
            ModulePath: {{printf "%q" .TraceMetadata.Program.ModulePath}},
            ModuleVersion: {{printf "%q" .TraceMetadata.Program.ModuleVersion}},
            MainPackage: {{printf "%q" .TraceMetadata.Program.MainPackage}},
        },
        Compiler: runtime.TraceCompilerMetadata{
            Version: {{printf "%q" .TraceMetadata.Compiler.Version}},
        },
    }

    close, err := interceptor.Open("trace.log", metadata)
    if err != nil {
        fmt.Fprintln(os.Stderr, "can't open trace file:", err.Error())
        os.Exit(1)
    }
    defer func() {
        if err := close(); err != nil {
            fmt.Fprintln(os.Stderr, "can't close trace file:", err.Error())
            os.Exit(1)
        }
    }()
    {{- else }}

    interceptor := runtime.ProdInterceptor{}
    {{- end }}

    var (
        startPort = runtime.NewSingleOutport(
            runtime.PortAddr{Path: "in", Port: "start"},
            interceptor,
            {{getPortChanNameByAddr "in" "start"}},
        )
        stopPort = runtime.NewSingleInport(
            {{getPortChanNameByAddr "out" "stop"}},
            runtime.PortAddr{Path: "out", Port: "stop"},
            interceptor,
        )
    )

    funcCalls := []runtime.FuncCall{
        {{- range .FuncCalls}}
        {
            Ref: "{{.Ref}}",
            IO: runtime.IO{
                In: runtime.NewInports(map[string]runtime.Inport{
                    {{- range $key, $value := .IO.In}}
                    "{{$key}}": {{$value}},
                    {{- end}}
                }),
                Out: runtime.NewOutports(map[string]runtime.Outport{
                    {{- range $key, $value := .IO.Out}}
                    "{{$key}}": {{$value}},
                    {{- end}}
                }),
            },
            Config: {{.Config}},
        },
        {{- end}}
    }

    rprog := runtime.Program{
        Start: startPort,
        Stop: stopPort,
        FuncCalls: funcCalls,
    }
    
    if err := runtime.Run(context.Background(), rprog, funcs.NewRegistry()); err != nil {
		fmt.Fprintln(os.Stderr, "runtime error:", err.Error())
		os.Exit(1)
	}
}
`
